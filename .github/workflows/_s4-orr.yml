name: dbt-gitleaks-and-sut

on:
  workflow_dispatch:
    inputs:
      run_sut:
        description: Start SUT via compose/npm
        required: false
        type: boolean
        default: false
  workflow_call:
    inputs:
      ref:
        description: "Ref opcional para checkout"
        required: false
        type: string
      run_sut:
        required: false
        type: boolean
        default: false
      run_microbench:
        description: "Executar microbench DEC"
        required: false
        type: boolean
        default: false
      run_tla:
        description: "Executar checagens TLA"
        required: false
        type: boolean
        default: false
    secrets:
      GCP_SA_JSON:
        required: false
      DBT_BQ_PROJECT:
        required: false
      DBT_BQ_DATASET:
        required: false
      DBT_BQ_LOCATION:
        required: false

jobs:
  orr:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref != '' && inputs.ref || github.ref }}

      - name: Instalar Gitleaks (tarball)
        shell: bash
        run: |
          set -euo pipefail
          if command -v gitleaks >/dev/null 2>&1; then
            echo "[setup] Gitleaks já presente: $(gitleaks version | head -n1)"
            exit 0
          fi
          VER="8.18.1"
          URL="https://github.com/gitleaks/gitleaks/releases/download/v${VER}/gitleaks_${VER}_linux_x64.tar.gz"
          echo "[setup] Baixando Gitleaks ${VER}"
          curl -fsSL "$URL" -o gitleaks.tgz
          tar -xzf gitleaks.tgz gitleaks
          sudo install -m 0755 gitleaks /usr/local/bin/gitleaks
          rm -f gitleaks gitleaks.tgz
          gitleaks version || { echo "[setup] gitleaks não responde"; exit 1; }

      - name: Mostrar versões das ferramentas
        shell: bash
        run: |
          set -euo pipefail
          echo "[setup] k6: $( (command -v k6 >/dev/null && k6 version) || echo 'não instalado ou usando Docker via K6_BIN')"
          echo "[setup] semgrep: $( (command -v semgrep >/dev/null && semgrep --version) || echo 'não instalado')"
          echo "[setup] trivy: $( (command -v trivy >/dev/null && trivy --version | head -n1) || echo 'não instalado')"
          echo "[setup] gitleaks: $( (command -v gitleaks >/dev/null && gitleaks version | head -n1) || echo 'não instalado')"

      - name: Localizar modelos TLA
        id: tla_scan
        if: ${{ (github.event_name == 'workflow_call' && inputs.run_tla) || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.run_tla || 'false')) }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          mapfile -t TLA_MODELS < <(git ls-files -z -- ':(glob)**/*.tla' | xargs -0 -r -n1 | sort -u)
          if [ "${#TLA_MODELS[@]}" -gt 0 ]; then
            printf '%s\n' "${TLA_MODELS[@]}" > out/tla_models.txt
            echo "have_tla=true" >> "$GITHUB_OUTPUT"
            echo "[tla] Modelos encontrados:";
            printf '  - %s\n' "${TLA_MODELS[@]}"
          else
            : > out/tla_models.txt
            echo "have_tla=false" >> "$GITHUB_OUTPUT"
            echo "[tla] Nenhum arquivo .tla encontrado; pulando checagens."
          fi

      - name: Guard ASCII para arquivos TLA
        if: ${{ ((github.event_name == 'workflow_call' && inputs.run_tla) || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.run_tla || 'false'))) && steps.tla_scan.outputs.have_tla == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          scripts/tla_ascii_guard.sh
          {
            echo "[tla] ASCII guard concluído às $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
            echo "[tla] Arquivos verificados:"
            cat out/tla_models.txt
          } > out/tla_ascii_report.txt

      - name: Login to GHCR for Apalache
        if: ${{ ((github.event_name == 'workflow_call' && inputs.run_tla) || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.run_tla || 'false'))) && steps.tla_scan.outputs.have_tla == 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_APALACHE_TOKEN }}

      - name: Apalache (pull + smoke)
        if: ${{ ((github.event_name == 'workflow_call' && inputs.run_tla) || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.run_tla || 'false'))) && steps.tla_scan.outputs.have_tla == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          REPORT="out/tla_apalache_smoke.txt"
          : > "$REPORT"
          docker pull ghcr.io/informalsystems/apalache:latest
          while IFS= read -r tla_file; do
            [ -z "$tla_file" ] && continue
            echo "[apalache] Checando ${tla_file}" | tee -a "$REPORT"
            docker run --rm \
              -v "$PWD":/var/apalache \
              -w /var/apalache \
              --workdir /var/apalache \
              ghcr.io/informalsystems/apalache:latest \
              check --init=Init --next=Next --inv=Safety "/var/apalache/${tla_file}" | tee -a "$REPORT"
          done < out/tla_models.txt

      - name: Upload ASCII report do TLA
        uses: actions/upload-artifact@v4
        if: ${{ always() && ((github.event_name == 'workflow_call' && inputs.run_tla) || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.run_tla || 'false'))) && steps.tla_scan.outputs.have_tla == 'true' }}
        with:
          name: tla-ascii-report
          path: |
            out/tla_ascii_report.txt
            out/tla_apalache_smoke.txt
          if-no-files-found: warn

      - name: Localizar projetos DBT
        id: dbt_scan
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          # Procura controlada (git ls-files evita varrer cache/node_modules não versionados)
          DBT_PROJECTS=()
          mapfile -t DBT_PROJECTS < <( git ls-files -z -- ':(glob)**/dbt_project.yml' | xargs -0 -r -n1 dirname | sort -u )
          printf '%s\n' "${DBT_PROJECTS[@]}" > out/dbt_projects.txt
          if [ "${#DBT_PROJECTS[@]}" -gt 0 ]; then
            echo "have_dbt=true" >> "$GITHUB_OUTPUT"
            echo "first=${DBT_PROJECTS[0]}" >> "$GITHUB_OUTPUT"
            echo "[dbt] Projetos encontrados:"; printf '  - %s\n' "${DBT_PROJECTS[@]}"
          else
            echo "have_dbt=false" >> "$GITHUB_OUTPUT"
            echo "[dbt] Nenhum dbt_project.yml encontrado; DBT será ignorado"
          fi

      - name: Preparar ambiente DBT (venv isolada)
        if: ${{ steps.dbt_scan.outputs.have_dbt == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          python -m venv .venv-dbt
          . .venv-dbt/bin/activate
          python -m pip install --upgrade pip
          # Versões fixas (compatíveis entre si); NÃO misturar com env global
          python -m pip install "dbt-core==1.6.4" "dbt-bigquery==1.6.4" "requests==2.31.0"
          deactivate

      - name: Validar segredos GCP/BigQuery para DBT
        id: dbt_secrets
        if: ${{ steps.dbt_scan.outputs.have_dbt == 'true' }}
        env:
          GCP_SA_JSON: ${{ secrets.GCP_SA_JSON }}
          DBT_BQ_PROJECT: ${{ secrets.DBT_BQ_PROJECT }}
          DBT_BQ_DATASET: ${{ secrets.DBT_BQ_DATASET }}
          DBT_BQ_LOCATION: ${{ secrets.DBT_BQ_LOCATION }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${GCP_SA_JSON:-}" ] && [ -n "${DBT_BQ_PROJECT:-}" ]; then
            echo "has_bq=true" >> "$GITHUB_OUTPUT"
            # Normaliza credencial em arquivo temporário e exporta GAC
            cred_file="$RUNNER_TEMP/gcp-sa.json"
            if printf '%s' "$GCP_SA_JSON" | grep -q '^{'; then
              printf '%s' "$GCP_SA_JSON" > "$cred_file"
            else
              # tenta decodificar base64; se falhar, grava bruto
              (printf '%s' "$GCP_SA_JSON" | base64 -d > "$cred_file") || printf '%s' "$GCP_SA_JSON" > "$cred_file"
            fi
            echo "GOOGLE_APPLICATION_CREDENTIALS=$cred_file" >> "$GITHUB_ENV"
            echo "[dbt] Segredos OK e credencial preparada"
          else
            echo "has_bq=false" >> "$GITHUB_OUTPUT"
            echo "[dbt] Segredos GCP/BigQuery ausentes; DBT será ignorado"
          fi

      - name: Executar DBT (deps, build, docs)
        if: ${{ steps.dbt_scan.outputs.have_dbt == 'true' && steps.dbt_secrets.outputs.has_bq == 'true' }}
        shell: bash
        env:
          DBT_BQ_PROJECT: ${{ secrets.DBT_BQ_PROJECT }}
          DBT_BQ_DATASET: ${{ secrets.DBT_BQ_DATASET }}
          DBT_BQ_LOCATION: ${{ secrets.DBT_BQ_LOCATION }}
        run: |
          set -euo pipefail
          . .venv-dbt/bin/activate
          while IFS= read -r project_dir; do
            [ -z "$project_dir" ] && continue
            echo "[dbt] Executando em: $project_dir"
            if [ -d "$project_dir/profiles" ]; then
              profiles="--profiles-dir $project_dir/profiles"
            else
              profiles="--profiles-dir $project_dir"
            fi
            dbt deps $profiles --project-dir "$project_dir"
            dbt build $profiles --project-dir "$project_dir"
            dbt docs generate $profiles --project-dir "$project_dir"
          done < out/dbt_projects.txt
          deactivate

      - name: Upload docs do DBT (se existirem)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dbt-docs
          path: |
            **/target/catalog.json
            **/target/manifest.json
            **/target/index.html
          if-no-files-found: ignore

      - name: Iniciar SUT (Compose/npm)
        if: ${{ (github.event_name == 'workflow_call' && inputs.run_sut) || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.run_sut || 'false')) }}
        shell: bash
        run: |
          set -euo pipefail
          echo "[sut] preparing start"
          mkdir -p out
          LOG_FILE="out/sut.log"
          : > "$LOG_FILE"
          echo "[sut] log file: $LOG_FILE"
          if [ "${EXTERNAL_SUT:-0}" = "1" ]; then
            echo "[sut] EXTERNAL_SUT=1 -> não iniciaremos processos locais"
            exit 0
          fi
          FILE=""
          for f in docker-compose.yml docker-compose.yaml compose.yaml; do
            if [ -f "$f" ]; then FILE="$f"; break; fi
          done
          if [ -n "$FILE" ] && command -v docker >/dev/null 2>&1; then
            echo "[sut] docker compose -f $FILE up -d --build"
            docker compose -f "$FILE" up -d --build
          else
            echo "[sut] docker/compose ausentes; nada a fazer"
          fi
