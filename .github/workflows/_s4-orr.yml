name: _s4-orr

on:
  workflow_call:
    inputs:
      ref:
        description: Optional ref to run against
        required: false
        type: string
      run_microbench:
        description: Enable microbench gate
        required: false
        type: boolean
        default: false
      run_tla:
        description: Enable TLA verification
        required: false
        type: boolean
        default: false
      run_sut:
        description: Start SUT via compose/npm
        required: false
        type: boolean
        default: false
      run_security:
        description: Enable security scanning gate
        required: false
        type: boolean
        default: false
      security_fail_on_findings:
        description: Fail workflow when security findings are detected
        required: false
        type: boolean
        default: false
    secrets:
      GCP_SA_JSON:
        required: false
      DBT_BQ_PROJECT:
        required: false
      DBT_BQ_DATASET:
        required: false
      DBT_BQ_LOCATION:
        required: false
      GHCR_APALACHE_TOKEN:
        required: false

concurrency:
  group: s4-orr-${{ inputs.ref || github.sha }}
  cancel-in-progress: true

permissions:
  contents: read
  actions: write
  id-token: write

jobs:
  orr:
    runs-on: ubuntu-22.04
    timeout-minutes: 120
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref || github.sha }}

      - name: Instalar Gitleaks (tarball)
        shell: bash
        run: |
          set -euo pipefail
          if command -v gitleaks >/dev/null 2>&1; then
            echo "[setup] Gitleaks já presente: $(gitleaks version | head -n1)"
            exit 0
          fi
          VER="8.18.1"
          URL="https://github.com/gitleaks/gitleaks/releases/download/v${VER}/gitleaks_${VER}_linux_x64.tar.gz"
          echo "[setup] Baixando Gitleaks ${VER}"
          curl -fsSL "$URL" -o gitleaks.tgz
          tar -xzf gitleaks.tgz gitleaks
          sudo install -m 0755 gitleaks /usr/local/bin/gitleaks
          rm -f gitleaks gitleaks.tgz
          gitleaks version || { echo "[setup] gitleaks não responde"; exit 1; }

      - name: Mostrar versões das ferramentas
        shell: bash
        run: |
          set -euo pipefail
          echo "[setup] k6: $( (command -v k6 >/dev/null && k6 version) || echo 'não instalado ou usando Docker via K6_BIN')"
          echo "[setup] semgrep: $( (command -v semgrep >/dev/null && semgrep --version) || echo 'não instalado')"
          echo "[setup] trivy: $( (command -v trivy >/dev/null && trivy --version | head -n1) || echo 'não instalado')"
          echo "[setup] gitleaks: $( (command -v gitleaks >/dev/null && gitleaks version | head -n1) || echo 'não instalado')"

      - name: Localizar modelos TLA
        id: tla_scan
        if: ${{ inputs.run_tla }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          mapfile -t TLA_MODELS < <(git ls-files -z -- ':(glob)**/*.tla' | xargs -0 -r -n1 | sort -u)
          if [ "${#TLA_MODELS[@]}" -gt 0 ]; then
            printf '%s\n' "${TLA_MODELS[@]}" > out/tla_models.txt
            echo "have_tla=true" >> "$GITHUB_OUTPUT"
            echo "[tla] Modelos encontrados:"
            printf '  - %s\n' "${TLA_MODELS[@]}"
          else
            : > out/tla_models.txt
            echo "have_tla=false" >> "$GITHUB_OUTPUT"
            echo "[tla] Nenhum arquivo .tla encontrado; pulando checagens."
          fi

      - name: Guard ASCII para arquivos TLA
        if: ${{ inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -x scripts/tla_ascii_guard.sh ]; then
            scripts/tla_ascii_guard.sh
          else
            echo "[tla] scripts/tla_ascii_guard.sh não encontrado; pulando guard"
          fi
          {
            echo "[tla] ASCII guard concluído às $(date -u +'%Y-%m-%dT%H:%M:%SZ')"
            echo "[tla] Arquivos verificados:"
            cat out/tla_models.txt
          } > out/tla_ascii_report.txt

      - name: Detectar GHCR token
        id: ghcr_tok
        if: ${{ inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        shell: bash
        env:
          GHCR_APALACHE_TOKEN: ${{ secrets.GHCR_APALACHE_TOKEN }}
        run: |
          set -euo pipefail
          if [ -n "${GHCR_APALACHE_TOKEN:-}" ]; then
            echo "has_token=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_token=false" >> "$GITHUB_OUTPUT"
          fi

      - name: GHCR login (opcional)
        if: ${{ inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' && steps.ghcr_tok.outputs.has_token == 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_APALACHE_TOKEN }}

      - name: TLA — Preparar workspace
        id: tla_ws_init
        if: ${{ inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out/s4_orr
          WORKDIR="$GITHUB_WORKSPACE"
          SEL_BASE="$(head -n1 out/tla_models.txt || true)"
          if [ -z "$SEL_BASE" ]; then
            echo "[tla] Nenhum modelo TLA disponível para preparação" >&2
            exit 1
          fi
          echo "workdir=${WORKDIR}" >> "$GITHUB_OUTPUT"
          echo "sel_base=${SEL_BASE}" >> "$GITHUB_OUTPUT"

      - name: TLA — Executar Apalache check
        if: ${{ inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        env:
          TLA_STRICT: ${{ env.TLA_STRICT }}
        shell: bash
        run: |
          set -uo pipefail
          REPORT="out/s4_orr/tla_report.txt"
          WORKDIR="${{ steps.tla_ws_init.outputs.workdir }}"
          SEL_BASE="${{ steps.tla_ws_init.outputs.sel_base }}"
          RC=0
          mkdir -p "$(dirname "$REPORT")"
          : > "$REPORT"
          if [ -z "$WORKDIR" ] || [ -z "$SEL_BASE" ]; then
            echo "[tla] Workspace ou modelo base não informado" | tee -a "$REPORT"
            RC=1
          else
            APAL_IMG="${APAL_IMG:-ghcr.io/apalache-mc/apalache:v0.50.3}"
            FALLBACK_IMG="ghcr.io/apalache-mc/apalache:main"
            echo "[tla] Tentando usar imagem ${APAL_IMG}" | tee -a "$REPORT"
            if ! docker pull "$APAL_IMG"; then
              echo "[tla] Falha ao puxar ${APAL_IMG}; tentando fallback ${FALLBACK_IMG}" | tee -a "$REPORT"
              if docker pull "$FALLBACK_IMG"; then
                APAL_IMG="$FALLBACK_IMG"
              else
                echo "[tla] Falha ao puxar imagem fallback ${FALLBACK_IMG}" | tee -a "$REPORT"
                RC=1
              fi
            fi
            if [ "$RC" -eq 0 ]; then
              echo "[tla] Executando apalache-mc check ${SEL_BASE}" | tee -a "$REPORT"
              docker run --rm \
                -v "$WORKDIR:/var/apalache:rw" \
                -w /var/apalache \
                "$APAL_IMG" \
                apalache-mc check "$SEL_BASE" | tee -a "$REPORT"
              RC=${PIPESTATUS[0]}
              if [ "$RC" -ne 0 ]; then
                echo "[tla] Execução falhou com código ${RC}; repetindo com -u 0:0" | tee -a "$REPORT"
                docker run --rm \
                  -u 0:0 \
                  -v "$WORKDIR:/var/apalache:rw" \
                  -w /var/apalache \
                  "$APAL_IMG" \
                  apalache-mc check "$SEL_BASE" | tee -a "$REPORT"
                RC=${PIPESTATUS[0]}
              fi
            fi
          fi
          STRICT="${TLA_STRICT:-0}"
          echo "[tla] Código de saída final: ${RC} (TLA_STRICT=${STRICT})" | tee -a "$REPORT"
          if [ "${STRICT}" = "1" ] && [ "$RC" -ne 0 ]; then
            exit "$RC"
          fi

      - name: TLA — Preparar workspace (bind-mount)
        id: tla_ws_bind
        if: ${{ inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          ensure_parent_copy() {
            local src="$1"
            [ -f "$src" ] || return 0
            if [ -n "${COPIED["$src"]:-}" ]; then
              return 0
            fi
            COPIED["$src"]=1
            mkdir -p "$WORKDIR"
            cp --parents "$src" "$WORKDIR/"
            printf '[tla-ws] Copiado: %s\n' "$src"
          }

          SEL_FILE="${TLA_SELECTED:-}"
          if [ -z "$SEL_FILE" ] && [ -f out/tla_selected.txt ]; then
            SEL_FILE="$(head -n1 out/tla_selected.txt | tr -d '\r')"
          fi
          if [ -z "$SEL_FILE" ] && [ -f out/tla_models.txt ]; then
            SEL_FILE="$(head -n1 out/tla_models.txt | tr -d '\r')"
          fi
          if [ -z "$SEL_FILE" ]; then
            echo "[tla-ws] Nenhum módulo selecionado para workspace" >&2
            exit 1
          fi
          if [ ! -f "$SEL_FILE" ]; then
            echo "[tla-ws] Arquivo selecionado não encontrado: $SEL_FILE" >&2
            exit 1
          fi

          WORKDIR="$GITHUB_WORKSPACE/out/s4_orr/apalache_work"
          rm -rf "$WORKDIR"
          mkdir -p "$WORKDIR"

          declare -A COPIED=()
          ensure_parent_copy "$SEL_FILE"

          SEL_DIR="$(dirname "$SEL_FILE")"
          while IFS= read -r -d '' dep; do
            ensure_parent_copy "$dep"
          done < <(find "$SEL_DIR" -maxdepth 1 -type f -name '*.tla' -print0)

          if [ -d docs/spec/tla ]; then
            while IFS= read -r -d '' lib; do
              ensure_parent_copy "$lib"
            done < <(find docs/spec/tla -type f -name '*.tla' -print0)
          fi

          SEL_BASE_NAME="$(basename "$SEL_FILE")"
          SEL_BASE="${SEL_BASE_NAME%.tla}"

          printf 'workdir=%s\n' "$WORKDIR" >> "$GITHUB_OUTPUT"
          printf 'sel_base=%s\n' "$SEL_BASE" >> "$GITHUB_OUTPUT"

          echo "::group::[tla-ws] Conteúdo do workspace"
          ls -la "$WORKDIR"
          find "$WORKDIR" -maxdepth 5 -type f -print
          echo "::endgroup::"

      - name: Upload ASCII/Apalache report
        uses: actions/upload-artifact@v4
        if: ${{ always() && inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        with:
          name: tla-reports
          path: |
            out/tla_ascii_report.txt
            out/s4_orr/tla_report.txt
          if-no-files-found: warn

      - name: Upload relatório TLA (Apalache)
        uses: actions/upload-artifact@v4
        if: ${{ always() && inputs.run_tla && steps.tla_scan.outputs.have_tla == 'true' }}
        with:
          name: tla-report
          path: out/s4_orr/tla_report.txt
          if-no-files-found: ignore

      - name: Localizar projetos DBT
        id: dbt_scan
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          DBT_PROJECTS=()
          mapfile -t DBT_PROJECTS < <( git ls-files -z -- ':(glob)**/dbt_project.yml' | xargs -0 -r -n1 dirname | sort -u )
          printf '%s\n' "${DBT_PROJECTS[@]}" > out/dbt_projects.txt
          if [ "${#DBT_PROJECTS[@]}" -gt 0 ]; then
            echo "have_dbt=true" >> "$GITHUB_OUTPUT"
            echo "first=${DBT_PROJECTS[0]}" >> "$GITHUB_OUTPUT"
            echo "[dbt] Projetos encontrados:"
            printf '  - %s\n' "${DBT_PROJECTS[@]}"
          else
            echo "have_dbt=false" >> "$GITHUB_OUTPUT"
            echo "[dbt] Nenhum dbt_project.yml encontrado; DBT será ignorado"
          fi

      - name: Preparar ambiente DBT (venv isolada)
        if: ${{ steps.dbt_scan.outputs.have_dbt == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          python -m venv .venv-dbt
          . .venv-dbt/bin/activate
          python -m pip install --upgrade pip
          python -m pip install "dbt-core==1.6.4" "dbt-bigquery==1.6.4" "requests==2.31.0"
          deactivate

      - name: Validar segredos GCP/BigQuery para DBT
        id: dbt_secrets
        if: ${{ steps.dbt_scan.outputs.have_dbt == 'true' }}
        env:
          GCP_SA_JSON: ${{ secrets.GCP_SA_JSON }}
          DBT_BQ_PROJECT: ${{ secrets.DBT_BQ_PROJECT }}
          DBT_BQ_DATASET: ${{ secrets.DBT_BQ_DATASET }}
          DBT_BQ_LOCATION: ${{ secrets.DBT_BQ_LOCATION }}
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${GCP_SA_JSON:-}" ] && [ -n "${DBT_BQ_PROJECT:-}" ]; then
            echo "has_bq=true" >> "$GITHUB_OUTPUT"
            cred_file="$RUNNER_TEMP/gcp-sa.json"
            if printf '%s' "$GCP_SA_JSON" | grep -q '^{'; then
              printf '%s' "$GCP_SA_JSON" > "$cred_file"
            else
              (printf '%s' "$GCP_SA_JSON" | base64 -d > "$cred_file") || printf '%s' "$GCP_SA_JSON" > "$cred_file"
            fi
            echo "GOOGLE_APPLICATION_CREDENTIALS=$cred_file" >> "$GITHUB_ENV"
            echo "[dbt] Segredos OK e credencial preparada"
          else
            echo "has_bq=false" >> "$GITHUB_OUTPUT"
            echo "[dbt] Segredos GCP/BigQuery ausentes; DBT será ignorado"
          fi

      - name: Executar DBT (deps, build, docs)
        if: ${{ steps.dbt_scan.outputs.have_dbt == 'true' && steps.dbt_secrets.outputs.has_bq == 'true' }}
        shell: bash
        env:
          DBT_BQ_PROJECT: ${{ secrets.DBT_BQ_PROJECT }}
          DBT_BQ_DATASET: ${{ secrets.DBT_BQ_DATASET }}
          DBT_BQ_LOCATION: ${{ secrets.DBT_BQ_LOCATION }}
        run: |
          set -euo pipefail
          . .venv-dbt/bin/activate
          while IFS= read -r project_dir; do
            [ -z "$project_dir" ] && continue
            echo "[dbt] Executando em: $project_dir"
            if [ -d "$project_dir/profiles" ]; then
              profiles="--profiles-dir $project_dir/profiles"
            else
              profiles="--profiles-dir $project_dir"
            fi
            dbt deps $profiles --project-dir "$project_dir"
            dbt build $profiles --project-dir "$project_dir"
            dbt docs generate $profiles --project-dir "$project_dir"
          done < out/dbt_projects.txt
          deactivate

      - name: Upload docs do DBT (se existirem)
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: dbt-docs
          path: |
            **/target/catalog.json
            **/target/manifest.json
            **/target/index.html
          if-no-files-found: ignore

      - name: Iniciar SUT (Compose/npm)
        if: ${{ inputs.run_sut }}
        shell: bash
        run: |
          set -euo pipefail
          echo "[sut] preparing start"
          mkdir -p out
          LOG_FILE="out/sut.log"
          : > "$LOG_FILE"
          echo "[sut] log file: $LOG_FILE"
          if [ "${EXTERNAL_SUT:-0}" = "1" ]; then
            echo "[sut] EXTERNAL_SUT=1 -> não iniciaremos processos locais"
            exit 0
          fi
          FILE=""
          for f in docker-compose.yml docker-compose.yaml compose.yaml; do
            if [ -f "$f" ]; then FILE="$f"; break; fi
          done
          if [ -n "$FILE" ] && command -v docker >/dev/null 2>&1; then
            echo "[sut] docker compose -f $FILE up -d --build"
            docker compose -f "$FILE" up -d --build
          else
            echo "[sut] docker/compose ausentes; nada a fazer"
          fi
