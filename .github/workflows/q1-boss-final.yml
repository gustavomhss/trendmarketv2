name: Q1 Boss Final

on:
  schedule:
    - cron: '0 7 * * *'
  workflow_dispatch:
    inputs:
      release_tag:
        description: Optional release tag to annotate the report
        required: false
        type: string
  pull_request:
    paths:
      - '.github/workflows/**'
      - 'scripts/**'
      - 's*/**'
      - 'docs/**'
      - 'dashboards/**'

concurrency:
  group: q1-boss-final-${{ github.ref }}
  cancel-in-progress: true

env:
  LC_ALL: C.UTF-8
  LANG: C.UTF-8
  PYTHONHASHSEED: '0'
  PYTHONUTF8: '1'
  HYPOTHESIS_PROFILE: ci
  HYPOTHESIS_SEED: '12345'

jobs:
  stage:
    name: Stage ${{ matrix.stage }} (clean=${{ matrix.clean_runner }})
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        stage: [s1, s2, s3, s4, s5, s6]
        clean_runner: [false, true]
    steps:
      - name: Checkout
        uses: actions/checkout@b4ffde65f46336ab3f3460e4f9d6a7152fb7a3b6

      - name: Set up Python
        uses: actions/setup-python@57ded73d95736b4867d21e0da0f2e054fea0f6e7
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Upgrade packaging toolchain
        run: |
          python -m pip install --upgrade pip==24.2 setuptools==75.1.0 wheel==0.44.0

      - name: Install Python dependencies
        run: |
          python -m pip install \
            -r requirements.lock \
            ruff==0.6.8 \
            yamllint==1.35.1 \
            pytest==8.3.3 \
            hypothesis==6.103.0 \
            jsonschema==4.23.0

      - name: Install jq
        if: matrix.stage != 's2'
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Install build tooling
        if: matrix.stage == 's2'
        run: sudo apt-get update && sudo apt-get install -y jq rustc cargo pkg-config libssl-dev

      - name: Execute sprint guard
        run: python scripts/boss_final/sprint_guard.py --stage ${{ matrix.stage }}
      - name: Install system dependencies
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Execute sprint guard
        timeout-minutes: 10
        run: |
          set -euo pipefail
          if [ "${{ matrix.clean_runner }}" = "true" ]; then
            variant="clean"
          else
            variant="primary"
          fi
          python scripts/boss_final/sprint_guard.py --stage "${{ matrix.stage }}" --variant "$variant"

      - name: Capture guard result
        id: guard
        run: |
          set -euo pipefail
          if [ "${{ matrix.clean_runner }}" = "true" ]; then
            variant="clean"
          else
            variant="primary"
          fi
          result_dir="out/q1_boss_final/stages/${{ matrix.stage }}/$variant"
          python - <<'PY' "$result_dir" "$GITHUB_OUTPUT"
from __future__ import annotations
import json
import sys
from pathlib import Path
variant_dir = Path(sys.argv[1])
output_path = Path(sys.argv[2])
result_path = variant_dir / "result.json"
if not result_path.exists():
    raise SystemExit(f"resultado ausente: {result_path}")
result = json.loads(result_path.read_text(encoding="utf-8"))
notes = result.get("notes", "").replace("\n", " ").strip()
with output_path.open("a", encoding="utf-8") as handle:
    handle.write(f"status={result.get('status', '').upper()}\n")
    handle.write(f"notes={notes}\n")
    handle.write(f"variant={result.get('variant', variant_dir.name)}\n")
    handle.write(f"variant_dir={variant_dir.as_posix()}\n")
    handle.write(f"stage_dir={variant_dir.parent.as_posix()}\n")
    handle.write(f"artifact_name=q1-boss-final-{result.get('stage', '')}-{result.get('variant', variant_dir.name)}\n")
PY

      - name: Publish stage summary
        uses: actions/github-script@11c33d7e17af65c2f8f5c38bf6e8f1525ba9a4d3
        env:
          STAGE: ${{ matrix.stage }}
          STATUS: ${{ steps.guard.outputs.status }}
          NOTES: ${{ steps.guard.outputs.notes }}
          VARIANT: ${{ steps.guard.outputs.variant }}
          IS_PR: ${{ github.event_name == 'pull_request' && 'true' || 'false' }}
        with:
          script: |
            const stage = process.env.STAGE.toUpperCase();
            const status = (process.env.STATUS || '').toUpperCase();
            const notes = process.env.NOTES || '';
            const variant = process.env.VARIANT || 'primary';
            const isPr = process.env.IS_PR === 'true';
            const heading = `Stage ${stage} (${variant})`;
            const body = `${status === 'PASS' ? '✅' : '❌'} ${heading} — **${status}**\n\n${notes}`;
            async function writeSummary() {
              core.summary.addHeading(heading, 3);
              core.summary.addRaw(`Status: **${status}**\n\n${notes}`);
              await core.summary.write();
            }
            try {
              if (isPr && variant === 'primary') {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body,
                });
              }
            } catch (error) {
              core.warning(`Falha ao comentar na PR: ${error.message}`);
            } finally {
              await writeSummary();
            }

      - name: Upload guard bundle
        uses: actions/upload-artifact@89ef406dd8d7e03cde85f3b4a7a6b5483c8f8c7a
        with:
          name: ${{ steps.guard.outputs.artifact_name }}
          path: ${{ steps.guard.outputs.stage_dir }}
          if-no-files-found: error

      - name: Upload guard artifacts
        if: always()
        uses: actions/upload-artifact@89ef406dd8d7e03cde85f3b4a7a6b5483c8f8c7a
        with:
          name: q1-boss-final-stage-${{ matrix.stage }}
          path: out/q1_boss_final/stages/${{ matrix.stage }}

      - name: Stage summary
        if: always()
        run: |
          stage='${{ matrix.stage }}'
          comment="out/q1_boss_final/stages/${stage}/comment.md"
          if [ -f "$comment" ]; then
            cat "$comment" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo "### Stage ${stage^^}";
              echo "";
              echo "⚠️ Stage ${stage^^} feedback indisponível. Confira os logs do job.";
              echo "";
            } >> "$GITHUB_STEP_SUMMARY"
          
      - name: Publish stage feedback
        if: ${{ always() && github.event_name == 'pull_request' }}
        uses: actions/github-script@11c33d7e17af65c2f8f5c38bf6e8f1525ba9a4d3
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const stage = '${{ matrix.stage }}'.toUpperCase();
            const base = path.join(process.cwd(), 'out', 'q1_boss_final', 'stages', '${{ matrix.stage }}');
            const commentPath = path.join(base, 'comment.md');
            let body = `⚠️ Stage ${stage} feedback indisponível. Consulte o GITHUB_STEP_SUMMARY.`;
            try {
              if (fs.existsSync(commentPath)) {
                body = fs.readFileSync(commentPath, 'utf8');
              }
            } catch (readError) {
              core.warning(`Falha ao ler comentário do estágio ${stage}: ${readError.message}`);
            }
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body,
              });
            } catch (apiError) {
              core.warning(`Falha ao publicar comentário do estágio ${stage}: ${apiError.message}`);
            }

  boss:
    name: Boss aggregator
    runs-on: ubuntu-latest
    needs: stage
    if: ${{ always() }}
    timeout-minutes: 60
    env:
      REPORT_DIR: out/q1_boss_final
    steps:
      - name: Checkout
        uses: actions/checkout@b4ffde65f46336ab3f3460e4f9d6a7152fb7a3b6

      - name: Set up Python
        uses: actions/setup-python@57ded73d95736b4867d21e0da0f2e054fea0f6e7
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Upgrade packaging toolchain
        run: |
          python -m pip install --upgrade pip==24.2 setuptools==75.1.0 wheel==0.44.0

      - name: Install Python dependencies
        run: |
          python -m pip install \
            -r requirements.lock \
            ruff==0.6.8 \
            yamllint==1.35.1 \
            pytest==8.3.3 \
            hypothesis==6.103.0 \
            jsonschema==4.23.0

      - name: Download stage artifacts
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          mkdir -p out/q1_boss_final/stages
          for stage in s1 s2 s3 s4 s5 s6; do
            gh run download ${{ github.run_id }} --name "q1-boss-final-stage-${stage}" --dir out/q1_boss_final/stages || true
            inner="out/q1_boss_final/stages/q1-boss-final-stage-${stage}"
            if [ -d "$inner/out/q1_boss_final/stages/${stage}" ]; then
              rm -rf "out/q1_boss_final/stages/${stage}"
              mv "$inner/out/q1_boss_final/stages/${stage}" "out/q1_boss_final/stages/${stage}"
            fi
            rm -rf "$inner"
          done
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          mkdir -p out/q1_boss_final/stages
          gh run download ${{ github.run_id }} --repo "$GITHUB_REPOSITORY" --pattern 'q1-boss-final-*' --dir out/q1_boss_final/stages

      - name: Normalize stage artifacts
        run: |
          set -euo pipefail
          python - <<'PY'
from __future__ import annotations
import json
import shutil
from pathlib import Path
root = Path('out/q1_boss_final/stages')
if root.exists():
    variant_dirs = {guard.parent.resolve() for guard in root.rglob('guard_status.txt')}
    for variant_dir in sorted(variant_dirs, key=lambda p: len(p.parts), reverse=True):
        if not variant_dir.exists():
            continue
        result_path = variant_dir / 'result.json'
        if not result_path.exists():
            continue
        data = json.loads(result_path.read_text(encoding='utf-8'))
        stage = (data.get('stage') or '').strip()
        variant = (data.get('variant') or variant_dir.name).strip() or variant_dir.name
        if not stage:
            continue
        target = root / stage / variant
        if target.resolve() == variant_dir:
            continue
        if target.exists():
            shutil.rmtree(target)
        target.parent.mkdir(parents=True, exist_ok=True)
        shutil.move(str(variant_dir), str(target))
    for path in sorted(root.glob('**/*'), key=lambda p: len(p.parts), reverse=True):
        if path.is_dir() and not any(path.iterdir()):
            path.rmdir()
PY

      - name: Aggregate Q1 boss report
        id: aggregate
        continue-on-error: true
        run: python scripts/boss_final/aggregate_q1.py

      - name: Upload aggregated artifacts
        if: always()
        uses: actions/upload-artifact@89ef406dd8d7e03cde85f3b4a7a6b5483c8f8c7a
        with:
          name: q1-boss-final-report
          path: ${{ env.REPORT_DIR }}

      - name: Validate report schema
        if: always()
        run: python -m jsonschema --instance "$REPORT_DIR/report.json" --schema schemas/q1_boss_report.schema.json

      - name: Evaluate guard status
        if: always()
        id: guard
        run: |
          status=$(cat "$REPORT_DIR/guard_status.txt")
          status=${status%%$'\n'}
          echo "guard_status=$status" >> $GITHUB_OUTPUT
          if [ "$status" != "PASS" ]; then
            exit 1
          fi

      - name: Boss summary
        if: always()
        run: |
          comment="$REPORT_DIR/pr_comment.md"
          if [ -f "$comment" ]; then
            cat "$comment" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
          else
            {
              echo '### Q1 Boss Final';
              echo "";
              echo '⚠️ Relatório não encontrado. Veja logs do job.';
              echo "";
            } >> "$GITHUB_STEP_SUMMARY"

      - name: Publish boss feedback
        if: ${{ always() && github.event_name == 'pull_request' }}
      - name: Publish boss summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@11c33d7e17af65c2f8f5c38bf6e8f1525ba9a4d3
        env:
          REPORT_DIR: ${{ env.REPORT_DIR }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const reportDir = process.env.REPORT_DIR || path.join(process.cwd(), 'out', 'q1_boss_final');
            const commentPath = path.join(reportDir, 'pr_comment.md');
            let body = '⚠️ Relatório não encontrado. Veja GITHUB_STEP_SUMMARY para detalhes.';
            try {
              if (fs.existsSync(commentPath)) {
                body = fs.readFileSync(commentPath, 'utf8');
              }
            } catch (readError) {
              core.warning(`Falha ao ler comentário do boss: ${readError.message}`);
            const reportDir = process.env.REPORT_DIR;
            const summaryPath = path.join(reportDir, 'pr_comment.md');
            const badgePath = path.join(reportDir, 'badge.svg');
            let body = '⚠️ Relatório não encontrado.';
            if (fs.existsSync(summaryPath)) {
              body = fs.readFileSync(summaryPath, 'utf8');
            }
            const heading = 'Q1 Boss Final';
            const badgeMarkup = fs.existsSync(badgePath) ? '![Status](./badge.svg)' : '';
            async function writeSummary() {
              core.summary.addHeading(heading);
              if (badgeMarkup) {
                core.summary.addRaw(badgeMarkup + '\n\n');
              }
              core.summary.addRaw(body);
              await core.summary.write();
            }
            try {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body,
              });
            } catch (apiError) {
              core.warning(`Falha ao publicar comentário do boss: ${apiError.message}`);
            } catch (error) {
              core.warning(`Falha ao comentar Boss Final: ${error.message}`);
            } finally {
              await writeSummary();
            }
